---
layout: post
title: "(P1) pydantic tutorial"
date: 2024-02-18 11:10:04 +0800
labels: [python]
---

## 动机、参考资料、涉及内容

`openai-python`, `langchain`, `llama_index`, `fastapi` 等项目大量用到了 `pydantic`, 并且 `pydantic` 本身也有 V1 版本与 V2 版本的区别. 对 V1 版本的使用方式是 `pydantic.v1`

Questions:

- `BaseModel` 里的 `Config` 是什么
- 装饰器 `root_validator`
- langchain: `AIMessage.update_forward_refs()`
- [json-schema](https://json-schema.org/learn/getting-started-step-by-step), 有可能另起一篇
- 较新版的 fastapi 应该使用 v2?, 但怎么做到客户端可以多传一些参数, 接口调用正常, 并且服务端怎么获取在 BaseModel 校验前的原始参数

### V1

#### type hint

#### validator

#### Config


### V1 to V2

感觉 API 变化很大, 不理解为什么要从 V1 升到 V2

- `llama_index` ([v0.9.31](https://github.com/run-llama/llama_index/blob/d7839442ab080347291bff0946c1e1ea2a7486ab/llama_index/bridge/pydantic.py), 发布时间 2024/1/16) 使用的是 V1
- `langchain` (v0.1.0, 发布时间 2024/01/06): 似乎在试图兼容 V1 与 V2, 但是否实际都是使用 pydantic.v1?
- `openai-python` (v1.2.3, 发布时间 2023/11/10): 似乎在试图兼容 V1 与 V2, 但是否实际都是使用 pydantic.v1?
- `fastapi`: 不确定?

#### bump-pydantic

以 [add default none](https://github.com/pydantic/bump-pydantic/blob/4aa32788c028c6d0b2066b0ca52db8fe127ef07e/bump_pydantic/codemods/add_default_none.py) 为例, 探究实现细节.

**转换前**

```python
# repo_folder/my_package/a.py
from pydantic import BaseModel

class Foo(BaseModel):
    bar: Optional[str]
    baz: Union[str, None]
    qux: Any
```

**转换方法**

```bash
pip install bump-pydantic
cd repo_folder
bump-pydantic my_package
```

**转换后**

```python
# repo_folder/my_package/a.py
from pydantic import BaseModel

class Foo(BaseModel):
    bar: Optional[str] = None
    baz: Union[str, None] = None
    qux: Any = None
```

大致原理是利用 libcst 构建 concrete syntax tree, 并且这个过程是无损的 (libcst 可以精确还原为原始代码, 而 python 自带的 ast 模块是有损的, 特别地, ast 不能精确还原空格和空行), 下面是一个简单的例子:

```python
import libcst
module = libcst.parse_module("a =(( 1+2))")  # 一个树状的数据结构
code = module.code  # "a =(( 1+2))"
```

`bump-pydantic` (以 [add default none](https://github.com/pydantic/bump-pydantic/blob/4aa32788c028c6d0b2066b0ca52db8fe127ef07e/bump_pydantic/codemods/add_default_none.py) 为例) 的实现原理就是修改 `module`, 然后还原为代码, 具体实现上则借助了 libcst 的一些内置工具, 大略如下.

```python
# 参考自: bump_pydantic/codemods/add_default_none.py
import libcst as cst
import libcst.matchers as m
from libcst.codemod import CodemodContext, VisitorBasedCodemodCommand
from libcst.metadata import FullyQualifiedNameProvider, QualifiedName
from libcst.metadata import FullRepoManager

class AddDefaultNoneCommand(VisitorBasedCodemodCommand):
    # 这里的 ClassDef 与 AnnAssign 是 libcst 中的节点类型, 在调用 visit 方法时, 会触发下面的这些方法:
    # 判断是否在 BaseModel 内
    def visit_ClassDef(self, node: cst.ClassDef) -> None: ...
    def leave_ClassDef(self, original_node: cst.ClassDef, updated_node: cst.ClassDef) -> cst.ClassDef: ...
    # 判断是否需要添加 `= None`
    def visit_AnnAssign(self, node: cst.AnnAssign) -> None: ...
    # 实现修改 `bar: Optional[str]` 为 `bar: Optional[str] = None` 的逻辑
    def leave_AnnAssign(self, original_node: cst.AnnAssign, updated_node: cst.AnnAssign) -> cst.AnnAssign: ...

tmpdir, module = "./", "./package_name/a.py"
mrg = FullRepoManager(tmpdir, {module}, providers={FullyQualifiedNameProvider})
wrapper = mrg.get_metadata_wrapper_for_path(module)
context = CodemodContext(wrapper=wrapper)

command = AddDefaultNoneCommand(context=context)  # type: ignore[assignment]
mod = wrapper.visit(command)
print(mod.code)
```

