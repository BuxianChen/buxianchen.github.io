---
layout: post
title: "(P0) leetcode 基础速通"
date: 2024-11-25 13:00:04 +0800
labels: [c++,python]
---

## 动机、参考资料、涉及内容

leetcode 算法题一些基础数据结构, 标准库的使用

## 基础数据结构



## C++ STL 容器相关方法

这个链接底部有一张表梳理容器的全部方法: [https://en.cppreference.com/w/cpp/container](https://en.cppreference.com/w/cpp/container)

**迭代器与 range based for**

```C++
#include<vector>
#include<iostream>
using namespace std;

int main(){
    int n = 5;
    vector<int> vec(n, 0);

    for (size_t i=0; i<5; i++){
        vec[i] = i;
    }

    for (auto const &item: vec){
        cout << item << " ";  // item 分别是 vec[0], vec[1], ... 的常引用
    }
    cout << "\n";
    auto it = vec.begin();  // 这里的 auto 实际上是 vector<int>::iterator
    auto const cit = vec.begin();  // 这里的 auto 是 vector<int>::const_iterator
    cout << *cit << endl;

    // 反向迭代器
    for (auto it = vec.rbegin(); it != vec.rend(); ++it) {
        std::cout << *it << " ";
    }
    cout << "\n";
}
```

**vector**

`vector` 的 `push_back`, `emplace_back`

**unordered_map, unordered_set**

**map, set**

**multiset, multimap, unorderd_multiset, unordered_multimap**

不带 multi 的表示键不允许重复, 带 unordered 采用哈希表实现, 不带 unordered 采用红黑树实现(因此支持范围查找). 头文件不区分 multi, 也就是:

- `#include<map>`: 包含 `map` 与 `multimap`
- `#include<set>`: 包含 `set` 与 `multiset`
- `#include<unordered_map>`: 包含 `unordered_map` 与 `unordered_multimap`
- `#include<unordered_set>`: 包含 `unordered_set` 与 `unordered_multiset`

**deque(不常用)**

**stack, queue, priority_queue**

stack, queue, priority_queue 均属于容器适配器

**heap**

## C++ STL algorithm

完整列表参考 [https://en.cppreference.com/w/cpp/algorithm](https://en.cppreference.com/w/cpp/algorithm)

**sort, 仿函数, lambda 函数**

```C++
// 此例为完整可运行的例子
#include<vector>
#include<algorithm>   // for std::sort
#include<functional>  // for std::greater, std::less
#include<iostream>    // for std::cout, std::endl

struct Compare {
    // 仿函数就是重载了 operator() 的雷
    bool operator()(int a, int b) {
        return a > b; // 降序
    }
};

int main(){
    std::vector<int> v1{1, 3, 2, 4, 6};  // C++11 一致性初始化的写法
    // sort 函数的第三个参数的语义是 func(a, b) -> a 是否小于 b
    std::sort(v1.begin(), v1.end(), Compare());  // 算法: 排序, 传入的参数是一个仿函数实例

    // lambda 函数的高级用法, 方括号内的内容是闭包
    auto print = [&v1](std::string const &rem)
    {
        for (auto const &a : v1)
            std::cout << a << ' ';
        std::cout << ": " << rem << '\n';
    };
    print("using function object");  // rem="using function object"

    std::vector<int> v2 = {1, 3, 2, 4, 6};
    // lambda 函数
    auto compare_lambda = [](int a, int b){return a > b;};
    std::sort(v2.begin(), v2.end(), compare_lambda);
    // 由于 v2 是 vector<int> 实际上传值效率也很快
    for (auto a: v2){
        std::cout << a << " ";
    }
    std::cout << ": " << "using lambda" << "\n";


    std::vector<int> v3 = {1, 3, 2, 4, 6};
    std::sort(v3.begin(), v3.end(), std::greater<int>());
    for (int i = 0; i < v3.size(); i++){
        std::cout << v3[i] << " ";
    }
    std::cout << ": " << "using standard library greater<T>()" << "\n";

    return 0;
}
```

lambda 函数的类型是无法显式写出, 但它确实有类型, 由编译器来生成. 在上面的例子里, 传入 lambda 函数或者仿函数时, 都会进行相应的模板实例化. 如果要强行写 lambda 函数的变量类型, 有两种方案:

```C++
auto cmp = [](int a, int b) { return a > b; };
decltype(cmp) another_cmp = cmp; // 使用 decltype 推导类型, C++11 特性

#include <functional>
// 所谓的类型擦除, 会影响性能. TODO
// 这里涉及到的 std::function, 与传统的函数指针的区别, 暂不深究: TODO
std::function<bool(int, int)> cmp = [](int a, int b) { return a > b; };
std::sort(v.begin(), v.end(), cmp);
```

## Python 内置数据结构

Python 中关于数据结构的实现比较有限

列表, 字典, 集合, 元组略.

排序相关:

sorted: TODO
bisect: TODO

队列: `queue.SimpleQueue` (队列), `queue.LifoQueue` (栈), `queue.PriorityQueue` (优先队列) 只提供了如下方法:

- 取出队列里的第一个元素: `get`
- 放入一个元素: `put`
- 当前队列长度: `qsize`
- 获取队列里的第一个元素但不取出: 不提供

堆:

ps: 堆和优先队列的区别, 堆是具体是数据结构, 一个满足特定条件的二叉树, 由于他是完全二叉树, 所以可以用数组实现. 而优先队列是抽象数据结构, 通常用堆来实现优先队列

TODO

图:

拓扑排序

```python
import graphlib

# key: 前驱节点集合
graph = {"D": {"B", "C"}, "C": {"A"}, "B": {"A"}}

# B -> D, C -> D, A -> C, A -> B
ts = graphlib.TopologicalSorter(graph)
try:
    print(tuple(ts.static_order()))  # A -> B -> C -> D
except graphlib.CycleError:
    print("Error")
```

## C++ 高级

本节只做记录, 不做展开

480-滑动窗口中位数, 官方题解实现里使用了函数模板, 来避免为 `std::priority_queue<int>` (大根堆), `std::priority_queue<int, std::vector<int>, std::greater<int>>` (小根堆) 写重复代码. 可以替代大做法是使用 C++17 引入的 `std::variant` 搭配 `std::visit` 来实现
