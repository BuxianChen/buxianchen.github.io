---
layout: post
title: "(LTS) WSGI & ASGI"
date: 2024-02-25 10:05:04 +0800
labels: [python, web]
---

## 动机、参考资料、涉及内容

**动机**

WSGI 协议? WSGI 框架 (例如 Flask), WSGI 服务器 (例如 gunicorn)

ASGI 协议? ASGI 框架 (例如 FastAPI), ASGI 服务器 (例如 uvicorn)

而 Flask 又提到了 werkzeug, FastAPI 又提到了 starlette (fastapi 基于此?)

以上这些概念到底是什么关系? 跟 socket 又有什么关系

web application:
web server:

**参考资料**

- WSGI application framework (对标 Flask), P1: [Blog: How to write a Python web framework](https://rahmonov.me/posts/write-python-framework-part-one/)
- WSGI server (对标 gunicorn), 质量一般: [Blog: Let's build a WSGI server](https://csrgxtu.github.io/2020/03/22/Let-s-build-a-WSGI-server/)
- ASGI application framework (对标 FastAPI): [Blog: asgi from scratch](https://shenli.dev/2020/06/20/asgi-from-scratch.html)
- web server (HTTP, WSGI 等) P2: [Blog: Let's build a web server](https://ruslanspivak.com/lsbaws-part1/)

**涉及内容**

socket

**不涉及内容**

flask, fastapi 的 API 介绍

## socket (TODO: 待确认, 大部分代码来自 ChatGPT)

socket 应该说是所有的 server 和 client 的底层, 从网络协议的角度来说, 自底向上主要有这几层协议 (以下举的具体协议例子是配套的)

- 数据链路层: 属于硬件层协议, 例如以太网 (Ethernet) 协议
- 网络层协议: 例如: IP 协议
- 传输层协议: 例如: TCP, UDP 协议
- 应用层协议: 例如: HTTP, websocket 协议

python 的内置模块 socket 实现了网络层与传输层的许多协议, 特别是 TCP 与 IP 协议

而 python 中的 WSGI, ASGI 协议是这样的: 在 python 网络编程中, 通常会有 3 个实体, 客户端, web server, web application. 对应于使用 Flask 技术栈写的程序来说, 对应关系如下:

- web application: 基于 Flask 框架写的 python 代码, 即:
  ```python
  from flask import Flask
  app = Flask(__name__)
  @app.route("/", methods=["GET"])
  def foo():
    return {"hello": "world"}
  ```
- web server: gunicorn
- client: 浏览器, 或者使用 `requests` 包写的发请求的客户端程序

```
web application <- WSGI/ASGI 协议 -> web server <- HTTP 协议 -> client
```

注意: `Flask` 是 web application framework (或者简称 web framework), 而使用它写的服务端代码才是 web application

有了这些概念之后, 下面看一下例子:

### socket server & socket client example

server 与 client 都使用 socket 直接实现, 并且 server 与 client 没有遵循常见的应用层 HTTP 协议.

**server**

```python
# socket_server.py
import socket

# 创建一个套接字对象
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 获取本地主机名
# host = socket.gethostname()
host = "127.0.0.1"
port = 12345

# 绑定地址与端口
server_socket.bind((host, port))

# 设置最大连接数
server_socket.listen(5)

print("等待客户端连接...")

while True:
    # 建立客户端连接
    client_socket, addr = server_socket.accept()
    
    print("连接地址: ", addr)

    # 发送消息给客户端
    response = 'Hello, client! This is the server response.'
    client_socket.send(response.encode('utf-8'))

    # 关闭连接
    client_socket.close()
```

**client**

```python
# socket_client.py
import socket

# 创建一个套接字对象
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 获取本地主机名
# host = socket.gethostname()
host = "127.0.0.1"
port = 12345

# 连接服务端
client_socket.connect((host, port))

# 获取本地端口号
local_port = client_socket.getsockname()[1]
print("客户端本地端口号:", local_port)

# 接收服务端的消息
message = client_socket.recv(1024)

print("来自服务器的消息: ", message.decode('utf-8'))

# 关闭连接
client_socket.close()
```

**运行**

```python
# 第一个终端
python socket_server.py
# 第二个终端
python socket_client.py
```

注意: 在上面的实现里, 如果启动 `socket_server.py` 后, 使用浏览器访问 `http://127.0.0.1:12345`, 浏览器会无法返回结果, 但启动 `socket_server.py` 的终端将打印出 `连接地址: xxx` 的信息. 这是因为在上面的实现里, 浏览器发出 GET 请求后, 其内容符合 HTTP 请求格式, 而 `socket_server.py` 可以接受任意格式的数据, 但其返回的数据不遵循 HTTP 相应数据的格式, 因此浏览器无法解读相应内容, 所以会无法返回结果.

**小结**

服务端与客户端都需要建立一个 socket 对象 (`socket.socket`), 并且都会占据一个端口, 服务端的端口一般是固定的, 而客户端的端口一般是在建立连接 `connect` 时自动分配的, 流程如下: 

```
socket   # server / client 建立 socket 对象
bind     # server
listen   # server
connect  # client 发起
accept   # server 端接受 connect
send     # server / client 都可以使用 send 方法, server 端一般是 send 响应内容, client 端一般是 send 请求内容
recv     # server / client 都可以使用 recv 方法, server 端一般是 recv 请求内容, client 端一般是 recv 响应内容
close    # server / client 都可以使用 close 方法用于关闭连接
```

### socket server & requests client

server 与 client 之间使用 HTTP 协议, server 的实现使用 socket, 客户端的实现使用 socket/requests (requests 实际上基于 socket), 本例实现 POST 请求的服务端和客户端代码

**server**

```diff
# socket_server.py
import socket

# 创建一个套接字对象
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 获取本地主机名
# host = socket.gethostname()
host = "127.0.0.1"
port = 12345

# 绑定地址与端口
server_socket.bind((host, port))

# 设置最大连接数
server_socket.listen(5)

print("等待客户端连接...")

while True:
    # 建立客户端连接
    client_socket, addr = server_socket.accept()

+     # 接受请求
+     request = client_socket.recv(1204)
    print("连接地址: ", addr)

    # 发送消息给客户端
-    response = 'Hello, client! This is the server response.'
+    response = "HTTP/1.1 200 OK\nContent-Type: text/html\n\nHello, client! This is the server response."
    client_socket.send(response.encode('utf-8'))

    # 关闭连接
    client_socket.close()
```

**client (socket)**

```diff
# socket_client.py
import socket

# 创建一个套接字对象
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 获取本地主机名
# host = socket.gethostname()
host = "127.0.0.1"
port = 12345

# 连接服务端
client_socket.connect((host, port))

# 获取本地端口号
local_port = client_socket.getsockname()[1]
print("客户端本地端口号:", local_port)

- # 接收服务端的消息
- message = client_socket.recv(1024)
- print("来自服务器的消息: ", message.decode('utf-8'))

+ # 构造HTTP请求
+ data = "key=value"
+ request = "POST / HTTP/1.1\nHost: {}:{}\nContent-Length: {}\nContent-Type: application/x-www-form-urlencoded\n\n{}".format(host, port, len(data), data)
+ # 发送请求
+ client_socket.send(request.encode('utf-8'))
+ # 接收服务器响应
+ response = client_socket.recv(1024)

# 关闭连接
client_socket.close()
```

**client (requests)**

```python
import requests
data = {'key': 'value'}
response = requests.post('http://localhost:12345', data=data)
print(response.text)
```

**总结**

实际上要用 socket 实现 HTTP 请求, 只是 `send` 与 `recv` 的数据满足格式要求, 即 HTTP 协议.

简要介绍一下 HTTP 协议的数据格式 (详情可参照: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)), 以 GET 请求为例, 客户端的请求数据格式为

```
GET <path> HTTP/1.1
<header-key-1>: <header-value-1>
<header-key-2>: <header-value-2>

<body>
```

例子:

```
GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```

服务端的相应数据格式

```
HTTP/1.1 <status-code> <status-message>
<header-key-1>: <header-value-1>
<header-key-2>: <header-value-2>

<body>
```

例子

```
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html>… (here come the 29769 bytes of the requested web page)
```

## WSGI (TODO: 需要先参考材料再总结)

本节主要实现一个 WSGI server (对标 gunicorn) 与 WSGI application framework (对标 Flask). 所谓的 WSGI 其实就是约定 WSGI application 需要是这种东西:

```python
# start_response 的类型是什么
def application(
    environ: Dict[str, Any],
    start_response: Callable[[str, list[Dict[str, Any]]], Any]
) -> Iterator[byte]:
    start_response(status, headers=[])
    return iter([response_body])
```

例子:

```python
# gunicorn wsgi_app:app

def app(environ, start_response):
    response_body = b"Hello, World!"
    status = "200 OK"
    start_response(status, headers=[])  # start_response: gunicorn.http.wsgi.Response
    print(environ)
    return iter([response_body])
```
