---
layout: post
title: "(LTS) WSGI & ASGI"
date: 2024-02-25 10:05:04 +0800
labels: [python, web]
---

## 动机、参考资料、涉及内容

**动机**

WSGI 协议? WSGI 框架 (例如 Flask), WSGI 服务器 (例如 gunicorn)

ASGI 协议? ASGI 框架 (例如 FastAPI), ASGI 服务器 (例如 uvicorn)

而 Flask 又提到了 werkzeug, FastAPI 又提到了 starlette (fastapi 基于此?)

以上这些概念到底是什么关系? 跟 socket 又有什么关系

web application:
web server:

**参考资料**

- [Blog: asgi from scratch](https://shenli.dev/2020/06/20/asgi-from-scratch.html)
- [Blog: Let's build a WSGI server](https://csrgxtu.github.io/2020/03/22/Let-s-build-a-WSGI-server/)
- [Blog: Let's build a web server](https://ruslanspivak.com/lsbaws-part1/)

**涉及内容**

socket

**不涉及内容**

flask, fastapi 的 API 介绍

## socket

**server**

```python
# socket_server.py
import socket

# 创建一个套接字对象
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 获取本地主机名
host = socket.gethostname()
port = 12345

# 绑定地址与端口
server_socket.bind((host, port))

# 设置最大连接数
server_socket.listen(5)

print("等待客户端连接...")

while True:
    # 建立客户端连接
    client_socket, addr = server_socket.accept()
    
    print("连接地址: ", addr)

    # 发送消息给客户端
    message = '欢迎访问服务器！'
    client_socket.send(message.encode('utf-8'))

    # 关闭连接
    client_socket.close()
```

**client**

```python
# client.py
import socket

# 创建一个套接字对象
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 获取本地主机名
host = socket.gethostname()
port = 12345

# 连接服务端
client_socket.connect((host, port))

# 获取本地端口号
local_port = client_socket.getsockname()[1]
print("客户端本地端口号:", local_port)

# 接收服务端的消息
message = client_socket.recv(1024)

print("来自服务器的消息: ", message.decode('utf-8'))

# 关闭连接
client_socket.close()
```

**运行**

```python
# 第一个终端
python socket_server.py
# 第二个终端
python socket_client.py
```

**小结**

服务端与客户端都需要建立一个 socket 对象 (`socket.socket`), 并且都会占据一个端口, 服务端的端口一般是固定的, 而客户端的端口一般是在建立连接 `connect` 时自动分配的, 流程如下: 

```
socket   # server / client 建立 socket 对象
bind     # server
listen   # server
connect  # client 发起
accept   # server 端接受 connect
send     # server / client 都可以使用 send 方法, server 端一般是 send 响应内容, client 端一般是 send 请求内容
recv     # server / client 都可以使用 recv 方法, server 端一般是 recv 请求内容, client 端一般是 recv 响应内容
close    # server / client 都可以使用 close 方法用于关闭连接
```
